#!/usr/bin/python3
# -*- coding: utf-8 -*-

from PyQt5.QtCore import Qt
from PyQt5.QtGui import QImage, QPixmap, QPalette, QPainter
from PyQt5.QtPrintSupport import QPrintDialog, QPrinter
from PyQt5.QtWidgets import QLabel, QSizePolicy, QScrollArea, QMessageBox, QMainWindow, QMenu, QAction, \
    qApp, QFileDialog

import numpy as np
from matplotlib import pyplot as plt
import scipy.optimize as spo
import sys,os,glob
import scipy.interpolate as spi

# This program is designed to illustrate and explore the entire
# OCT/ORG processing pipeline. octoblob functions are copied and
# simplified here to facilitate understanding of the algorithms.
# (Spectra stored in NPY files were generated by running
# octoblob.processors.process_bscans with the parameter
# save_spectra=True. When applicable, these have already been
# aligned using the fiber bragg grating notch.)

# The shape of the spectra is (n_k,n_x), where n_k is the number of
# points along the k (wavenumber) axis and n_x is the number of points
# along the x (fast scan) axis.
# print('spectra shape:', spectra.shape)


dB_lims = (45,85)

# Now we'll define some functions for the half-dozen or so processing
# steps:

# We need a way to estimate and remove DC:
def dc_subtract(spectra):
    """Estimate DC by averaging spectra spatially (dimension 1),
    then subtract by broadcasting."""
    dc = spectra.mean(1)
    # Do the subtraction by array broadcasting, for efficiency.
    # See: https://numpy.org/doc/stable/user/basics.broadcasting.html
    out = (spectra.T-dc).T
    return out


# Next we need a way to adjust the values of k at each sample, and then
# interpolate into uniformly sampled k:
def k_resample(spectra,coefficients):
    """Resample the spectrum such that it is uniform w/r/t k.
    Notes:
      1. The coefficients here are for a polynomial defined on
         pixels, so they're physically meaningless. It would be
         better to define our polynomials on k, because then
         we could more easily quantify and compare the chirps
         of multiple light sources, for instance. Ditto for the
         dispersion compensation code.
    """
    # x_in specified on array index 1..N+1
    x_in = np.arange(1,spectra.shape[0]+1)

    # define an error polynomial, using the passed coefficients, and then
    # use this polynomial to define the error at each index 1..N+1
    error = np.polyval(coefficients,x_in)
    x_out = x_in + error

    # using the spectra measured at indices x_in, interpolate the spectra at indices x_out
    # See: https://docs.scipy.org/doc/scipy/reference/generated/scipy.interpolate.interp1d.html
    interpolator = spi.interp1d(x_in,spectra,axis=0,kind='cubic',fill_value='extrapolate')
    interpolated = interpolator(x_out)
    return interpolated

# Next we need to dispersion compensate; for historical reasons the correction polynomial
# is defined on index x rather than k, but for physically meaningful numbers we should
# use k instead
def dispersion_compensate(spectra,coefficients):
    coefs = list(coefficients) + [0.0,0.0]
    # define index x:
    x = np.arange(1,spectra.shape[0]+1)
    # define the phasor and multiply by spectra using broadcasting:
    dechirping_phasor = np.exp(-1j*np.polyval(coefs,x))
    dechirped = (spectra.T*dechirping_phasor).T
    return dechirped


# Next we multiply the spectra by a Gaussian window, in order to reduce ringing
# in the B-scan due to edges in the spectra:
def gaussian_window(spectra,sigma):
    # Define a Gaussian window with passed sigma
    x = np.exp(-((np.linspace(-1.0,1.0,spectra.shape[0]))**2/sigma))
    # Multiply spectra by window using broadcasting:
    out = (spectra.T*x).T
    return out


# Now let's define a processing function that takes the spectra and two dispersion coefficients
# and produces a B-scan:
def process_bscan(spectra,mapping_coefficients=[0.0],dispersion_coefficients=[0.0],window_sigma=0.9):
    spectra = dc_subtract(spectra)
    # When we call dispersion_compensate, we have to pass the c3 and c2 coefficients as well as
    # two 0.0 values, to make clear that we want orders 3, 2, 1, 0. This enables us to use the
    # polyval function of numpy instead of writing the polynomial ourselves, e.g. c3*x**3+c2*x**x**2,
    # since the latter is more likely to cause bugs.
    spectra = k_resample(spectra,mapping_coefficients)
    spectra = dispersion_compensate(spectra,dispersion_coefficients)
    spectra = gaussian_window(spectra,sigma=window_sigma)
    bscan = np.fft.fft(spectra,axis=0)
    return bscan


def get_bscan_qimage(filename,mapping_coefficients=[0.0],dispersion_coefficients=[0.0],window_sigma=0.9):
    spectra = np.load(filename)
    bscan = process_bscan(spectra,mapping_coefficients,dispersion_coefficients,window_sigma)
    bscan = 20*np.log10(np.abs(bscan))

    bscan = np.clip(bscan,*dB_lims)
    bscan = bscan/np.max(bscan)
    bscan = bscan*255
    img = np.round(bscan).astype(np.uint8)
    
    #qimage = QImage(bscan.data, w, h, 3 * w, QImage.Format_RGB888)


    img = np.zeros((bscan.shape[0], bscan.shape[1]), dtype=np.uint8)
    img[:] = bscan[:]
    # Turn up red channel to full scale
    #img[...,0] = 255
    qimage = QImage(img.data, img.shape[1], img.shape[0], QImage.Format_Grayscale8)
    
    #qimage = QImage(bscan,bscan.shape[1],bscan.shape[0],QImage.Format_RGB888)
    return qimage

if False:
    # Define dispersion coefficients; these were taken from a recent run of the optimizer:
    c2 =4.002501838354675e-06,
    c3=-1.0535075482720929e-08,

    # Let's see what we get:
    bscan = process_bscan(spectra,[c3,c2])

    bscan_dB = 20*np.log10(np.abs(bscan))
    plt.imshow(bscan_dB,cmap='gray',clim=(40,80))
    plt.show()


# An example of optimizing dispersion:

# First, we need an objective function that takes the two dispersion coefficients and outputs
# a single value to be minimized; for simplicity, we'll use the reciprocal of the brightest
# pixel in the image. An oddity here is that the function can see outside its scope and thus
# has access to the variable 'spectra', defined at the top by loading from the NPY file. We
# then call our process_bscans function, using the coefficients passed into this objective
# function. From the resulting B-scan, we calculate our value to be minimized:
def obj_func(coefs,save=False):
    bscan = process_bscan(spectra,coefs)
    # we don't need the complex conjugate, so let's determine the size of the B-scan and crop
    # the bottom half (sz//2:) for use. (// means integer division--we can't index with floats;
    # also, the sz//2: is implied indexing to the bottom of the B-scan:
    sz,sx = bscan.shape
    bscan = bscan[sz//2:,:]
    # we also want to avoid DC artifacts from dominating the image brightness or gradients,
    # so let's remove the bottom, using negative indexing.
    # See: https://numpy.org/devdocs/user/basics.indexing.html
    bscan = bscan[:-50,:]
    # Finally let's compute the amplitude (modulus) max and return its reciprocal:
    bscan = np.abs(bscan)
    bscan = bscan[-300:] # IMPORTANT--THIS WON'T WORK IN GENERAL, ONLY ON THIS DATA SET 16_53_25
    out = 1.0/np.max(bscan)
    
    # Maybe we want to visualize it; change to False to speed things up
    if True:
        # clear the current axis
        plt.cla()
        # show the image:
        plt.imshow(20*np.log10(bscan),cmap='gray',clim=dB_lims)
        # pause:
        plt.pause(0.001)

    if save:
        order = len(coefs)+1
        os.makedirs('dispersion_compensation_results',exist_ok=True)
        plt.cla()
        plt.imshow(20*np.log10(bscan),cmap='gray',clim=dB_lims)
        plt.title('order %d\n %s'%(order,list(coefs)+[0.0,0.0]),fontsize=10)
        plt.colorbar()
        plt.savefig('dispersion_compensation_results/order_%d.png'%order,dpi=150)
    return out


# Now we can define some settings for the optimization:

def optimize_dispersion(spectra,obj_func,initial_guess):

    # spo.minimize accepts an additional argument, a dictionary containing further
    # options; we want can specify an error tolerance, say about 1% of the bounds.
    # we can also specify maximum iterations:
    optimization_options = {'xatol':1e-10,'maxiter':10000}

    # optimization algorithm:
    # See: https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html
    method = 'nelder-mead'


    # Now we run it; Nelder-Mead cannot use bounds, so we pass None
    res = spo.minimize(obj_func,initial_guess,method='nelder-mead',bounds=None,options=optimization_options)

    print('Optimization result (order: %d):'%order)
    print(res.x)
    print(obj_func(res.x,save=True))





class QImageViewer(QMainWindow):
    def __init__(self):
        super().__init__()

        self.printer = QPrinter()
        self.scaleFactor = 0.0

        self.imageLabel = QLabel()
        self.imageLabel.setBackgroundRole(QPalette.Base)
        self.imageLabel.setSizePolicy(QSizePolicy.Ignored, QSizePolicy.Ignored)
        self.imageLabel.setScaledContents(True)

        self.scrollArea = QScrollArea()
        self.scrollArea.setBackgroundRole(QPalette.Dark)
        self.scrollArea.setWidget(self.imageLabel)
        self.scrollArea.setVisible(False)

        self.setCentralWidget(self.scrollArea)

        self.createActions()
        self.createMenus()

        self.setWindowTitle("Image Viewer")
        self.resize(800, 600)

    def open(self):
        options = QFileDialog.Options()
        # fileName = QFileDialog.getOpenFileName(self, "Open File", QDir.currentPath())
        fileName, _ = QFileDialog.getOpenFileName(self, 'QFileDialog.getOpenFileName()', '',
                                                  'Images (*.npy)', options=options)
        if fileName:

            image = get_bscan_qimage(fileName)
            
            #image = QImage(fileName)


            
            if image.isNull():
                QMessageBox.information(self, "Image Viewer", "Cannot load %s." % fileName)
                return

            self.imageLabel.setPixmap(QPixmap.fromImage(image))
            self.scaleFactor = 1.0

            self.scrollArea.setVisible(True)
            self.printAct.setEnabled(True)
            self.fitToWindowAct.setEnabled(True)
            self.updateActions()

            if not self.fitToWindowAct.isChecked():
                self.imageLabel.adjustSize()

    def print_(self):
        dialog = QPrintDialog(self.printer, self)
        if dialog.exec_():
            painter = QPainter(self.printer)
            rect = painter.viewport()
            size = self.imageLabel.pixmap().size()
            size.scale(rect.size(), Qt.KeepAspectRatio)
            painter.setViewport(rect.x(), rect.y(), size.width(), size.height())
            painter.setWindow(self.imageLabel.pixmap().rect())
            painter.drawPixmap(0, 0, self.imageLabel.pixmap())

    def zoomIn(self):
        self.scaleImage(1.25)

    def zoomOut(self):
        self.scaleImage(0.8)

    def normalSize(self):
        self.imageLabel.adjustSize()
        self.scaleFactor = 1.0

    def fitToWindow(self):
        fitToWindow = self.fitToWindowAct.isChecked()
        self.scrollArea.setWidgetResizable(fitToWindow)
        if not fitToWindow:
            self.normalSize()

        self.updateActions()

    def about(self):
        QMessageBox.about(self, "About Image Viewer",
                          "<p>The <b>Image Viewer</b> example shows how to combine "
                          "QLabel and QScrollArea to display an image. QLabel is "
                          "typically used for displaying text, but it can also display "
                          "an image. QScrollArea provides a scrolling view around "
                          "another widget. If the child widget exceeds the size of the "
                          "frame, QScrollArea automatically provides scroll bars.</p>"
                          "<p>The example demonstrates how QLabel's ability to scale "
                          "its contents (QLabel.scaledContents), and QScrollArea's "
                          "ability to automatically resize its contents "
                          "(QScrollArea.widgetResizable), can be used to implement "
                          "zooming and scaling features.</p>"
                          "<p>In addition the example shows how to use QPainter to "
                          "print an image.</p>")

    def createActions(self):
        self.openAct = QAction("&Open...", self, shortcut="Ctrl+O", triggered=self.open)
        self.printAct = QAction("&Print...", self, shortcut="Ctrl+P", enabled=False, triggered=self.print_)
        self.exitAct = QAction("E&xit", self, shortcut="Ctrl+Q", triggered=self.close)
        self.zoomInAct = QAction("Zoom &In (25%)", self, shortcut="Ctrl++", enabled=False, triggered=self.zoomIn)
        self.zoomOutAct = QAction("Zoom &Out (25%)", self, shortcut="Ctrl+-", enabled=False, triggered=self.zoomOut)
        self.normalSizeAct = QAction("&Normal Size", self, shortcut="Ctrl+S", enabled=False, triggered=self.normalSize)
        self.fitToWindowAct = QAction("&Fit to Window", self, enabled=False, checkable=True, shortcut="Ctrl+F",
                                      triggered=self.fitToWindow)
        self.aboutAct = QAction("&About", self, triggered=self.about)
        self.aboutQtAct = QAction("About &Qt", self, triggered=qApp.aboutQt)

    def createMenus(self):
        self.fileMenu = QMenu("&File", self)
        self.fileMenu.addAction(self.openAct)
        self.fileMenu.addAction(self.printAct)
        self.fileMenu.addSeparator()
        self.fileMenu.addAction(self.exitAct)

        self.viewMenu = QMenu("&View", self)
        self.viewMenu.addAction(self.zoomInAct)
        self.viewMenu.addAction(self.zoomOutAct)
        self.viewMenu.addAction(self.normalSizeAct)
        self.viewMenu.addSeparator()
        self.viewMenu.addAction(self.fitToWindowAct)

        self.helpMenu = QMenu("&Help", self)
        self.helpMenu.addAction(self.aboutAct)
        self.helpMenu.addAction(self.aboutQtAct)

        self.menuBar().addMenu(self.fileMenu)
        self.menuBar().addMenu(self.viewMenu)
        self.menuBar().addMenu(self.helpMenu)

    def updateActions(self):
        self.zoomInAct.setEnabled(not self.fitToWindowAct.isChecked())
        self.zoomOutAct.setEnabled(not self.fitToWindowAct.isChecked())
        self.normalSizeAct.setEnabled(not self.fitToWindowAct.isChecked())

    def scaleImage(self, factor):
        self.scaleFactor *= factor
        self.imageLabel.resize(self.scaleFactor * self.imageLabel.pixmap().size())

        self.adjustScrollBar(self.scrollArea.horizontalScrollBar(), factor)
        self.adjustScrollBar(self.scrollArea.verticalScrollBar(), factor)

        self.zoomInAct.setEnabled(self.scaleFactor < 3.0)
        self.zoomOutAct.setEnabled(self.scaleFactor > 0.333)

    def adjustScrollBar(self, scrollBar, factor):
        scrollBar.setValue(int(factor * scrollBar.value()
                               + ((factor - 1) * scrollBar.pageStep() / 2)))


if __name__ == '__main__':
    import sys
    from PyQt5.QtWidgets import QApplication

    app = QApplication(sys.argv)
    imageViewer = QImageViewer()
    imageViewer.show()
    sys.exit(app.exec_())
    # TODO QScrollArea support mouse
    # base on https://github.com/baoboa/pyqt5/blob/master/examples/widgets/imageviewer.py
    #
    # if you need Two Image Synchronous Scrolling in the window by PyQt5 and Python 3
    # please visit https://gist.github.com/acbetter/e7d0c600fdc0865f4b0ee05a17b858f2
