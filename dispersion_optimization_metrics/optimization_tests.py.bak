from octoblob import functions as blobf
import numpy as np
from matplotlib import pyplot as plt
import time
import scipy.optimize as spo

dB_lims = (43,88)

spectra = blobf.load_spectra('spectra_00100.npy')
spectra = blobf.dc_subtract(spectra)

def crop_bscan(bscan,top_crop=300,bottom_crop=50):
    sz,sx = bscan.shape
    bscan = bscan[sz//2:,:]
    # remove dc
    bscan = bscan[top_crop:-bottom_crop,:]
    return bscan

def show_bscan(bscan,iqf,ax=plt.gca()):
    ax.clear()
    ax.imshow(20*np.log10(bscan),cmap='gray',clim=dB_lims)
    ax.set_title(iqf(bscan))
    plt.pause(0.000001)

def bscan_m(mcoefs,spectra):
    spectra = blobf.k_resample(spectra,mcoefs)
    bscan = np.abs(np.fft.fft(spectra,axis=0))
    bscan = crop_bscan(bscan)
    return bscan

def bscan_d(dcoefs,spectra):
    spectra = blobf.dispersion_compensate(spectra,dcoefs)
    bscan = np.abs(np.fft.fft(spectra,axis=0))
    bscan = crop_bscan(bscan)
    return bscan

def bscan_md(mdcoefs,spectra):
    spectra = blobf.k_resample(spectra,mdcoefs[:2])
    spectra = blobf.dispersion_compensate(spectra,mdcoefs[2:])
    bscan = np.abs(np.fft.fft(spectra,axis=0))
    bscan = crop_bscan(bscan)
    return bscan

def obj_m(mcoefs,spectra,show,iqf):
    """Optimize mapping"""
    bscan = bscan_m(mcoefs,spectra)
    if show:
        show_bscan(bscan,iqf)
    return 1.0/iqf(bscan)

def obj_d(dcoefs,spectra,show,iqf):
    """Optimze dispersion"""
    bscan = bscan_d(dcoefs,spectra)
    if show:
        show_bscan(bscan,iqf)
    return 1.0/iqf(bscan)

def obj_md(mdcoefs,spectra,show,iqf):
    """Optimize mapping and dispersion"""
    bscan = bscan_md(mdcoefs,spectra)
    if show:
        show_bscan(bscan,iqf)
    return 1.0/iqf(bscan)


# spo.minimize accepts an additional argument, a dictionary containing further
# options; we want can specify an error tolerance, say about 1% of the bounds.
# we can also specify maximum iterations:
optimization_options = {'xatol':1e-10,'maxiter':1000}

# optimization algorithm:
# See: https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html
method = 'nelder-mead'

m_bounds = [(-2e-8,1e-9),(-6e-5,2e-6)]

d_bounds = [(-5e-8,5e-8),(-1e-4,1e-4)]
md_bounds = m_bounds+d_bounds


def run(obj_f,bscan_f,spectra,iqf=blobf.sharpness):
    if obj_f==obj_md:
        init = [0.0,0.0,0.0,0.0]
    else:
        init = [0.0,0.0]

    if obj_f==obj_md:
        bounds = md_bounds
    elif obj_f==obj_d:
        bounds = d_bounds
    elif obj_f==obj_m:
        bounds = m_bounds

    fig = plt.figure(figsize=(6,3))
    ax1,ax2 = fig.subplots(1,2)
    ax1.set_title('%s (pre)'%obj_f.__doc__)
    show_bscan(bscan_f(init,spectra),iqf,ax1)#,cmap='gray',aspect='auto')
    res = spo.minimize(obj_f,init,args=(spectra,False,iqf),bounds=bounds,method=method,options=optimization_options)
    ax2.set_title('%s (post)'%obj_f.__doc__)
    show_bscan(bscan_f(res.x,spectra),iqf,ax2)#,cmap='gray',aspect='auto')
    plt.show()
    
run(obj_d,bscan_d,spectra)


#res = spo.minimize(obj_d,[0.0,0.0],args=(spectra,True,blobf.iq_max),method=method,options=optimization_options)
#res = spo.minimize(obj_d,[0.0,0.0],args=(spectra,True,blobf.iq_max),method=method,options=optimization_options)

